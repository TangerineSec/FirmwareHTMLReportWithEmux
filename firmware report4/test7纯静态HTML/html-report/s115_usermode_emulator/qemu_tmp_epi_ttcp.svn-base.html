<!-- 
EMBA - EMBEDDED LINUX ANALYZER

Copyright 2020-2023 Siemens AG
Copyright 2020-2024 Siemens Energy AG

EMBA comes with ABSOLUTELY NO WARRANTY. This is free software, and you are
welcome to redistribute it under the terms of the GNU General Public License.
See LICENSE file for usage of this software.

EMBA is licensed under GPLv3

Author(s) and contributors from the EMBA project are listed here: https://github.com/e-m-b-a/emba/blob/master/CONTRIBUTORS.md
-->

<!-- Used icons: https://github.com/CoreyGinnivan/system-uicons -->
 
<!DOCTYPE html>
<html lang="en">
<head>
  <title>EMBA firmware report</title>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="./../style/style.css" type="text/css">
  <link rel="icon" type="image/png" href="./../style/favicon.png">
</head>
<body>

<div id="sidenav" class="side">
  <div id="logo">
    <a class="inherit" href="./../index.html"><img class="inherit" id="logoImage" src="./../style/emba.svg" alt="logo"></a>
  </div>
  <div id="nav">
      <a id="embark" class="hidden" href="{{ embarkBackUrl }}">&laquo; Back to EMBArk</a> <!-- nosem -->
      <a class="backButton" href="./../index.html">&laquo; Back to main</a>
<a class="modul" href="./../s115_usermode_emulator.html" title="./../s115_usermode_emulator.html" >&laquo; Back to s115_usermode_emulator</a>
      <!-- navigation start -->
      <!-- navigation end -->
      <input id="expand" class="expand_njs hidden" type="button" value="More results:" onclick="this.value=this.value=='+ Show more results'?'- Hide more results':'+ Show more results';">
      <div class="expand_area">
        <!-- etc start -->
        <!-- etc end -->
      </div>
  </div>
  <a href="TIMELINK"><div id="buttonTimeInvisible" class="rectButton"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round" transform="matrix(-1 0 0 1 19 2)"><circle cx="8.5" cy="8.5" r="8"/><path d="M8.5 5.5v4H5"/></g></svg></div></a>
  <div id="buttonSizer" class="rectButton buttonClose" onclick="buttonNav()"></div>
</div>
<div id="main" class="main">
  <!-- content start -->
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary name: </span><span class="orange">epi_ttcp.svn-base</span></pre>
<pre>[</span><span class="orange">*</span>] Emulator used: </span><span class="orange">qemu-arm-static</span></pre>
<pre>[</span><span class="orange">*</span>] Using root directory: </span><span class="orange">/logs/s115_usermode_emulator/firmware/squashfs-root</span> (</span><span class="orange">1/1</span>)</pre>
<pre>[</span><span class="orange">*</span>] Using CPU config: </span><span class="orange">NONE</span></pre>
<pre>[</span><span class="orange">*</span>] Emulating binary: </span><span class="orange">/usr/sbin/.svn/text-base/epi_ttcp.svn-base</span></pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">NONE</span></pre>
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>sockbufsndsize=16384, sockbufrcvsize=131072, sockbufsize=73728, </pre>
<pre># tcp receiver #</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">-v</span></pre>
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>ttcp-r: bind: Address already in use</pre>
<pre>ttcp-r: errno=98</pre>
<pre>ttcp-r: start time Wed Jan 10 21:52:06 2024</pre>
<pre>ttcp-r: File-Descriptor 0x3 Opened</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">-V</span></pre>
<pre>ttcp.c $- CERN Revision: 3.8 (dev level) -$ Epigram 15-jul-98</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">-h</span></pre>
<pre> Details about the reply: </pre>
<pre>   Example: </pre>
<pre>   ttcp-t: buflen=8192, nbuf=100, align=16384/0, port=5010</pre>
<pre>   ttcp-t: File-Descriptor 0x4 Opened</pre>
<pre>   # tcp sender -&gt; &lt;host&gt; #</pre>
<pre>   ttcp-t: 819200 bytes in 1.152557 real seconds = 694.109 KB/sec +++</pre>
<pre>   ttcp-t: 100 I/O calls, 11.526 msec(real)/call, 0.213 msec(cpu)/call</pre>
<pre>   ttcp-t: 0.001914user 0.019388sys 0:01real 1        0+58d 190maxrss 1+2pf 177+180csw</pre>
<pre>   ttcp-t: buffer address 0x28000</pre>
<pre>   ttcp-t: File-Descriptor  fd 0x4 Closed</pre>
<pre>   ttcp done.</pre>
<br />
<pre>cpu seconds  ==  (sec) elapse ru_utime + elapse ru_stime.</pre>
<pre>                 ru_utime == The total amount of time running in user mode.</pre>
<pre>                 ru_stime == The total amount of time spent in the system.</pre>
<pre>                             executing on behalf of the process.</pre>
<pre>real seconds ==  elapse time calculated by the system timer (date).</pre>
<pre>I/O calls    ==  I/O call to the driver.</pre>
<pre>msec/call    ==  average elapse time (Real seconds) between each I/O.</pre>
<pre>calls/sec    ==  invert of msec/call.</pre>
<pre>user         ==  (sec.msec) elaspe ru_utime.</pre>
<pre>sys          ==  (sec.msec) elapse ru_stime.</pre>
<pre>real         ==  (min:sec)  CPU seconds.</pre>
<pre>%           ==  Real seconds / CPU seconds.</pre>
<pre>(ru_ixrss)i+(ru_idrss)d</pre>
<pre>             ru_ixrss  == An integral value indicating the amount of memory </pre>
<pre>                          used by the text segment that was also shared among</pre>
<pre>                          other processes. This value is expressed in units of</pre>
<pre>                          kilobytes * seconds-of-execution and is calculated </pre>
<pre>                          by adding the number of shared memory pages in use </pre>
<pre>                          each time the internal system clock ticks, and then</pre>
<pre>                          averaging over one-second intervals.</pre>
<pre>             ru_idrss  == An integral value of the amount of unshared memory </pre>
<pre>                          in the data segment of a process (expressed in </pre>
<pre>                          units of kilobytes * seconds-of-execution).</pre>
<pre>  (ru_maxrss/2)maxrss.</pre>
<pre>             ru_maxrss == The maximum size, in kilobytes, of the used</pre>
<pre>                          resident set size. </pre>
<pre>  (ru_majflt)+(ru_minflt)pf : Page fault</pre>
<pre>             ru_majflt == The number of page faults serviced that required</pre>
<pre>                          I/O activity.</pre>
<pre>             ru_minflt == The number of page faults serviced without any</pre>
<pre>                          I/O activity. In this case, I/O activity is </pre>
<pre>                          avoided by reclaiming a page frame from the list </pre>
<pre>                          of pages awaiting reallocation. </pre>
<pre>(ru_nvcsw)+(ru_nivcsw)csw : context switch</pre>
<pre>             ru_nvcsw  == The number of times a context switch resulted </pre>
<pre>                          because a process voluntarily gave up the </pre>
<pre>                          processor before its time slice was completed. </pre>
<pre>                          This usually occurs while the process waits </pre>
<pre>                          for availability of a resource.</pre>
<pre>             ru_nivcsw == The number of times a context switch resulted </pre>
<pre>                          because a higher priority process ran or because</pre>
<pre>                          the current process exceeded its time slice.</pre>
<br />
<pre>)</pre>
<pre>         nbytes(byte), realt(sec), rate(MB/sec), I/O call,</pre>
<pre>                 hours*3600+min*60+sec</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">-help</span></pre>
<pre> Details about the reply: </pre>
<pre>   Example: </pre>
<pre>   ttcp-t: buflen=8192, nbuf=100, align=16384/0, port=5010</pre>
<pre>   ttcp-t: File-Descriptor 0x4 Opened</pre>
<pre>   # tcp sender -&gt; &lt;host&gt; #</pre>
<pre>   ttcp-t: 819200 bytes in 1.152557 real seconds = 694.109 KB/sec +++</pre>
<pre>   ttcp-t: 100 I/O calls, 11.526 msec(real)/call, 0.213 msec(cpu)/call</pre>
<pre>   ttcp-t: 0.001914user 0.019388sys 0:01real 1        0+58d 190maxrss 1+2pf 177+180csw</pre>
<pre>   ttcp-t: buffer address 0x28000</pre>
<pre>   ttcp-t: File-Descriptor  fd 0x4 Closed</pre>
<pre>   ttcp done.</pre>
<br />
<pre>cpu seconds  ==  (sec) elapse ru_utime + elapse ru_stime.</pre>
<pre>                 ru_utime == The total amount of time running in user mode.</pre>
<pre>                 ru_stime == The total amount of time spent in the system.</pre>
<pre>                             executing on behalf of the process.</pre>
<pre>real seconds ==  elapse time calculated by the system timer (date).</pre>
<pre>I/O calls    ==  I/O call to the driver.</pre>
<pre>msec/call    ==  average elapse time (Real seconds) between each I/O.</pre>
<pre>calls/sec    ==  invert of msec/call.</pre>
<pre>user         ==  (sec.msec) elaspe ru_utime.</pre>
<pre>sys          ==  (sec.msec) elapse ru_stime.</pre>
<pre>real         ==  (min:sec)  CPU seconds.</pre>
<pre>%           ==  Real seconds / CPU seconds.</pre>
<pre>(ru_ixrss)i+(ru_idrss)d</pre>
<pre>             ru_ixrss  == An integral value indicating the amount of memory </pre>
<pre>                          used by the text segment that was also shared among</pre>
<pre>                          other processes. This value is expressed in units of</pre>
<pre>                          kilobytes * seconds-of-execution and is calculated </pre>
<pre>                          by adding the number of shared memory pages in use </pre>
<pre>                          each time the internal system clock ticks, and then</pre>
<pre>                          averaging over one-second intervals.</pre>
<pre>             ru_idrss  == An integral value of the amount of unshared memory </pre>
<pre>                          in the data segment of a process (expressed in </pre>
<pre>                          units of kilobytes * seconds-of-execution).</pre>
<pre>  (ru_maxrss/2)maxrss.</pre>
<pre>             ru_maxrss == The maximum size, in kilobytes, of the used</pre>
<pre>                          resident set size. </pre>
<pre>  (ru_majflt)+(ru_minflt)pf : Page fault</pre>
<pre>             ru_majflt == The number of page faults serviced that required</pre>
<pre>                          I/O activity.</pre>
<pre>             ru_minflt == The number of page faults serviced without any</pre>
<pre>                          I/O activity. In this case, I/O activity is </pre>
<pre>                          avoided by reclaiming a page frame from the list </pre>
<pre>                          of pages awaiting reallocation. </pre>
<pre>(ru_nvcsw)+(ru_nivcsw)csw : context switch</pre>
<pre>             ru_nvcsw  == The number of times a context switch resulted </pre>
<pre>                          because a process voluntarily gave up the </pre>
<pre>                          processor before its time slice was completed. </pre>
<pre>                          This usually occurs while the process waits </pre>
<pre>                          for availability of a resource.</pre>
<pre>             ru_nivcsw == The number of times a context switch resulted </pre>
<pre>                          because a higher priority process ran or because</pre>
<pre>                          the current process exceeded its time slice.</pre>
<br />
<pre>)</pre>
<pre>         nbytes(byte), realt(sec), rate(MB/sec), I/O call,</pre>
<pre>                 hours*3600+min*60+sec</pre>
<br />
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">--help</span></pre>
<pre>./usr/sbin/.svn/text-base/epi_ttcp.svn-base: invalid option -- -</pre>
<pre>  Usage: ttcp -t [-options] host [ &lt; in ]    ttcp -r [-options &gt; out]</pre>
<pre>Example: ttcp -t -s -v -n100 host            ttcp -r -s -v -n100</pre>
<pre>Common options:</pre>
<pre>    -V      prints version number and date of last modification</pre>
<pre>    -L      create and append all results to a file named ttcp_log</pre>
<pre>    -h      more help</pre>
<pre>    -l ##   length of bufs read from or written to network (default 8192,</pre>
<pre>            max 65535)</pre>
<pre>    -u      use UDP instead of TCP</pre>
<pre>    -p ##   port number to send to or listen at (default 5010)</pre>
<pre>    -P ##   link-layer priority (default 0)</pre>
<pre>    -s      (ttcp -t) : source a pattern to network</pre>
<pre>            (ttcp -r) : sink (discard) all data from network</pre>
<pre>    -A ##   align the start of buffers to this modulus (default 16384)</pre>
<pre>    -O ##   start buffers at this offset from the modulus (default 0)</pre>
<pre>    -v      verbose: print more statistics</pre>
<pre>    -d      set SO_DEBUG socket option</pre>
<pre>    -b ##   set socket buffer size (if supported)</pre>
<pre>    -f X    format for rate: b,B = bits, bytes k,K = kilo{bits,bytes};</pre>
<pre>                             m,M = mega{bits,bytes}; g,G = giga{bits,bytes}</pre>
<pre>    -w ##   set timeout value (in milliseconds) to exit if no receive data or tcp connect</pre>
<pre>Options specific to (ttcp -t) :</pre>
<pre>    -n ##   number of source bufs written to network (default 2048)</pre>
<pre>    -x      use random data in tcp/udp frames (-I provides seed)</pre>
<pre>    -D      don't buffer TCP writes (sets TCP_NODELAY socket option)</pre>
<pre>    -H      print hash marks to indicate progress, one per buffer</pre>
<pre>    -# ##   number of buffers to send between hash marks (implies -H)</pre>
<pre>    -I      init/seed value for RNG when sending random size bufs (default 1)</pre>
<pre>    -N ##   number of source bufs per burst, i.e between sleeps (default 1)</pre>
<pre>    -R ##   send random size buffers with minimum size specified, max size</pre>
<pre>            is value of -l option</pre>
<pre>    -S ##   millisecs between bursts (10ms resolution)</pre>
<pre>Options specific to (ttcp -r) :</pre>
<pre>    -B      for -s, only output full blocks as specified by -l (for TAR)</pre>
<pre>    -T      "touch": access each byte as it's read</pre>
<pre>    -i      report information on out of order sequence numbers</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">--version</span></pre>
<pre>./usr/sbin/.svn/text-base/epi_ttcp.svn-base: invalid option -- -</pre>
<pre>  Usage: ttcp -t [-options] host [ &lt; in ]    ttcp -r [-options &gt; out]</pre>
<pre>Example: ttcp -t -s -v -n100 host            ttcp -r -s -v -n100</pre>
<pre>Common options:</pre>
<pre>    -V      prints version number and date of last modification</pre>
<pre>    -L      create and append all results to a file named ttcp_log</pre>
<pre>    -h      more help</pre>
<pre>    -l ##   length of bufs read from or written to network (default 8192,</pre>
<pre>            max 65535)</pre>
<pre>    -u      use UDP instead of TCP</pre>
<pre>    -p ##   port number to send to or listen at (default 5010)</pre>
<pre>    -P ##   link-layer priority (default 0)</pre>
<pre>    -s      (ttcp -t) : source a pattern to network</pre>
<pre>            (ttcp -r) : sink (discard) all data from network</pre>
<pre>    -A ##   align the start of buffers to this modulus (default 16384)</pre>
<pre>    -O ##   start buffers at this offset from the modulus (default 0)</pre>
<pre>    -v      verbose: print more statistics</pre>
<pre>    -d      set SO_DEBUG socket option</pre>
<pre>    -b ##   set socket buffer size (if supported)</pre>
<pre>    -f X    format for rate: b,B = bits, bytes k,K = kilo{bits,bytes};</pre>
<pre>                             m,M = mega{bits,bytes}; g,G = giga{bits,bytes}</pre>
<pre>    -w ##   set timeout value (in milliseconds) to exit if no receive data or tcp connect</pre>
<pre>Options specific to (ttcp -t) :</pre>
<pre>    -n ##   number of source bufs written to network (default 2048)</pre>
<pre>    -x      use random data in tcp/udp frames (-I provides seed)</pre>
<pre>    -D      don't buffer TCP writes (sets TCP_NODELAY socket option)</pre>
<pre>    -H      print hash marks to indicate progress, one per buffer</pre>
<pre>    -# ##   number of buffers to send between hash marks (implies -H)</pre>
<pre>    -I      init/seed value for RNG when sending random size bufs (default 1)</pre>
<pre>    -N ##   number of source bufs per burst, i.e between sleeps (default 1)</pre>
<pre>    -R ##   send random size buffers with minimum size specified, max size</pre>
<pre>            is value of -l option</pre>
<pre>    -S ##   millisecs between bursts (10ms resolution)</pre>
<pre>Options specific to (ttcp -r) :</pre>
<pre>    -B      for -s, only output full blocks as specified by -l (for TAR)</pre>
<pre>    -T      "touch": access each byte as it's read</pre>
<pre>    -i      report information on out of order sequence numbers</pre>
<pre>[</span><span class="orange">*</span>] Emulating binary </span><span class="orange">./usr/sbin/.svn/text-base/epi_ttcp.svn-base</span> with parameter </span><span class="orange">version</span></pre>
<br />
<pre>-----------------------------------------------------------------</pre>
<br />
<pre>ttcp-r: buflen=8192, nbuf=2048, align=16384/0, port=5010</pre>
<pre>ttcp-r: bind: Address already in use</pre>
<pre>ttcp-r: errno=98</pre>
  <!-- content end -->
</div>

<a href="https://github.com/e-m-b-a/emba" title="github.com/e-m-b-a/emba" target="_blank">
  <div id="buttonInfo" class="rectButtonVisible">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" transform="translate(2 2)"><g stroke="white" stroke-linecap="round" stroke-linejoin="round"><circle cx="8.5" cy="8.5" r="8"/><path d="M8.5 12.5v-4h-1"/><path d="M7.5 12.5h2"/></g><circle cx="8.5" cy="5.5" fill="white" r="1"/></g></svg>
  </div>
</a>
<div id="buttonBack" class="nonClickable rectButtonVisible"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><path d="M9.5 14.5l4-4l-4-4" fill="none" stroke="#444" stroke-linecap="round" stroke-linejoin="round"/></svg></div>
<div id="buttonForward" class="nonClickable rectButtonVisible"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><path d="M11.5 14.5l-4-4l4-4" fill="none" stroke="#444" stroke-linecap="round" stroke-linejoin="round"/></svg></div> 
<div id="buttonDown" class="rectButton" onclick="scrollDown()"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 6.5l-4 4l-4-4"/><path d="M14.5 10.5l-4 4l-4-4"/></g></svg></div>
<div id="buttonUp" class="rectButton" onclick="scrollUp()"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="#fff" stroke-linecap="round" stroke-linejoin="round"><path d="M6.5 14.5l4-4l4 4"/><path d="M6.5 10.5l4-4l4 4"/></g></svg></div> 

<script>
window.onload = function () {
  var buttons = document.getElementsByClassName("rectButton");
  for (let i=0; i<buttons.length; i++) {
    buttons[i].style.visibility = "visible";
  }
  var buttonDown = document.getElementById("buttonDown");
  buttonDown.classList.add('rectButtonVisible');
  buttonDown.classList.remove('rectButton');

  var buttonUp = document.getElementById("buttonUp");
  buttonUp.classList.add('rectButtonVisible');
  buttonUp.classList.remove('rectButton');
    
  var buttonSizer = document.getElementById("buttonSizer");
  buttonSizer.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M9.5 16.5v-4.978l-5-.022"/><path d="M18.5 2.5l-7 7"/><path d="M16.5 9.5l-5 .023V4.5"/><path d="M9.5 11.5l-7 7"/></g></svg>';
  if (document.getElementById("buttonTime") !== null) {
    var buttonTime = document.getElementById("buttonTime");
    buttonTime.style.bottom = "50px";
  }
  document.getElementById("expand").value = "+ Show more results";
  document.getElementById("expand").className += " expand";
  var embarkButton = document.getElementById("embark");
  if ( !(embarkButton.href.includes("embarkBackUrl")) ) {
    embarkButton.classList.remove('hidden');
    document.getElementById("logoImage").src = "./../style/embark.svg";
    document.getElementById("logo").style.background = "#2d2d2d";
  }
}

function openNav() {
  document.getElementById("sidenav").style.width = "250px";
  document.getElementById("main").style.marginLeft = "250px";
  document.getElementById("nav").style.visibility = "visible";
}

function closeNav() {
  document.getElementById("sidenav").style.width = "50px";
  document.getElementById("sidenav").scrollTop = 0;
  document.getElementById("main").style.marginLeft = "50px";
  document.getElementById("nav").style.visibility = "hidden";
}

function scrollDown() {
  window.scrollTo(0,document.body.scrollHeight);
}

function scrollUp() {
  window.scrollTo(0,0);
}

function buttonNav() {
  var button = document.getElementById("buttonSizer");
  if ( button.classList.contains('buttonOpen') ) {
    button.classList.remove('buttonOpen');
    button.classList.add('buttonClose');
    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M9.5 16.5v-4.978l-5-.022"/><path d="M18.5 2.5l-7 7"/><path d="M16.5 9.5l-5 .023V4.5"/><path d="M9.5 11.5l-7 7"/></g></svg>';
    openNav();
  } else if( button.classList.contains('buttonClose') ) {
    button.classList.remove('buttonClose');
    button.classList.add('buttonOpen');
    button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" focusable="false" width="40" height="40" style="-ms-transform: rotate(360deg); -webkit-transform: rotate(360deg); transform: rotate(360deg);" preserveAspectRatio="xMidYMid meet" viewBox="0 0 21 21"><g fill="none" fill-rule="evenodd" stroke="white" stroke-linecap="round" stroke-linejoin="round"><path d="M18.5 7.5v-5h-5"/><path d="M18.5 2.5l-6 5.929"/><path d="M7.5 18.5l-5 .023V13.5"/><path d="M8.5 12.5l-6 6"/></g></svg>';
    closeNav();
  };
}

// the following function is currently not used
// it is for future extensions
function overlay_output(link) {
  var rawfile = new XMLHttpRequest();
  rawfile.open('GET', link, false);
  rawfile.overrideMimeType("text");
  rawfile.onreadystatechange = function()
  {
    alert(rawfile.responseText);
    //console.log(rawfile.responseText);
  }
  rawfile.send(null);
}

document.onkeydown = function(e) {
    switch (e.keyCode) {
      case 37:
        document.getElementById("buttonForward").parentNode.click(); 
        break;
      case 39:
        document.getElementById("buttonBack").parentNode.click();       
        break;
    }
};
</script>

</body>
</html>
